// cmd/codegen/types.go
package main

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

func generateTypes(spec *Spec, outDir string) error {
	f, err := os.Create(filepath.Join(outDir, "types.go"))
	if err != nil {
		return err
	}
	defer f.Close()

	fmt.Fprintln(f, "// Code generated by codegen. DO NOT EDIT.")
	fmt.Fprintln(f, "package gen")
	fmt.Fprintln(f)

	// Sort types for deterministic output
	names := make([]string, 0, len(spec.Types))
	for name := range spec.Types {
		names = append(names, name)
	}
	sort.Strings(names)

	for _, name := range names {
		t := spec.Types[name]
		if err := writeType(f, t); err != nil {
			return err
		}
	}

	return nil
}

func writeType(f *os.File, t Type) error {
	// Write doc comment
	if len(t.Description) > 0 {
		fmt.Fprintf(f, "// %s %s\n", t.Name, t.Description[0])
	}

	fmt.Fprintf(f, "type %s struct {\n", t.Name)

	for _, field := range t.Fields {
		goType := toGoType(field.Types, !field.Required)
		jsonTag := field.Name
		if !field.Required {
			jsonTag += ",omitempty"
		}
		fmt.Fprintf(f, "\t%s %s `json:\"%s\"`\n", toCamelCase(field.Name), goType, jsonTag)
	}

	fmt.Fprintln(f, "}")
	fmt.Fprintln(f)

	return nil
}

func toGoType(types []string, optional bool) string {
	if len(types) == 0 {
		return "interface{}"
	}

	t := types[0]

	// Handle arrays
	if strings.HasPrefix(t, "Array of ") {
		inner := strings.TrimPrefix(t, "Array of ")
		return "[]" + toGoType([]string{inner}, false)
	}

	// Map Telegram types to Go types
	switch t {
	case "Integer":
		if optional {
			return "*int64"
		}
		return "int64"
	case "Float", "Float number":
		if optional {
			return "*float64"
		}
		return "float64"
	case "String":
		return "string"
	case "Boolean", "True":
		if optional {
			return "*bool"
		}
		return "bool"
	case "InputFile":
		return "interface{}" // Can be file upload or string
	default:
		// Union types or complex types
		if len(types) > 1 {
			return "interface{}"
		}
		if optional {
			return "*" + t
		}
		return t
	}
}

func toCamelCase(s string) string {
	parts := strings.Split(s, "_")
	for i := range parts {
		parts[i] = strings.ToUpper(parts[i][:1]) + parts[i][1:]
	}
	return strings.Join(parts, "")
}
