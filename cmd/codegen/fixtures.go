// cmd/codegen/fixtures.go
package main

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

func generateFixtures(spec *Spec, outDir string) error {
	f, err := os.Create(filepath.Join(outDir, "fixtures.go"))
	if err != nil {
		return err
	}
	defer f.Close()

	fmt.Fprintln(f, "// Code generated by codegen. DO NOT EDIT.")
	fmt.Fprintln(f, "package gen")
	fmt.Fprintln(f)
	fmt.Fprintln(f, "import \"time\"")
	fmt.Fprintln(f)
	fmt.Fprintln(f, "var _ = time.Now // Ensure time is used")
	fmt.Fprintln(f)

	names := make([]string, 0, len(spec.Types))
	for name := range spec.Types {
		names = append(names, name)
	}
	sort.Strings(names)

	for _, name := range names {
		t := spec.Types[name]
		if err := writeFixture(f, t, spec); err != nil {
			return err
		}
	}

	return nil
}

func writeFixture(f *os.File, t Type, spec *Spec) error {
	fmt.Fprintf(f, "// New%s creates a fixture %s\n", t.Name, t.Name)
	fmt.Fprintf(f, "func New%s() *%s {\n", t.Name, t.Name)
	fmt.Fprintf(f, "\treturn &%s{\n", t.Name)

	for _, field := range t.Fields {
		if !field.Required {
			continue // Skip optional fields in fixtures
		}
		val := fixtureValue(field, spec)
		fmt.Fprintf(f, "\t\t%s: %s,\n", toCamelCase(field.Name), val)
	}

	fmt.Fprintln(f, "\t}")
	fmt.Fprintln(f, "}")
	fmt.Fprintln(f)

	return nil
}

func fixtureValue(field Field, spec *Spec) string {
	if len(field.Types) == 0 {
		return "nil"
	}

	t := field.Types[0]

	if strings.HasPrefix(t, "Array of ") {
		return "nil"
	}

	switch t {
	case "Integer":
		// Special cases
		switch field.Name {
		case "date":
			return "int64(time.Now().Unix())"
		case "message_id":
			return "1"
		case "update_id":
			return "1"
		default:
			return "1"
		}
	case "Float", "Float number":
		return "1.0"
	case "String":
		switch field.Name {
		case "type":
			return `"private"`
		case "text":
			return `"Hello"`
		case "first_name":
			return `"Test"`
		case "username":
			return `"testuser"`
		case "title":
			return `"Test Chat"`
		default:
			return fmt.Sprintf("%q", field.Name)
		}
	case "Boolean", "True":
		return "true"
	default:
		// Check if it's a known type
		if _, ok := spec.Types[t]; ok {
			return fmt.Sprintf("*New%s()", t)
		}
		return "nil"
	}
}
